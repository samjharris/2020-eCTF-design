#!/usr/bin/env python3
"""
Description: Protects song by adding metadata or any other security measures
Use: Once per song
"""
import binascii
import json
import struct
import os
import wave
from argparse import ArgumentParser
import numpy as np

import pyhy
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

u8e = lambda n: struct.pack("B", n)
u8d = lambda b: struct.unpack("B", b)[0]
u16e = lambda n: struct.pack("H", n)
u16d = lambda b: struct.unpack("H", b)[0]
u32e = lambda n: struct.pack("I", n)
u32d = lambda b: struct.unpack("I", b)[0]

CONTEXT = "AAAAAAAA"

def chunk(b, n): return [b[i*n:(i+1)*n] for i in range(len(b)//n)]

def encrypt_data(data, key, iv):
    cipher = AES.new(key, AES.MODE_CTR, nonce=iv)
    return cipher.encrypt(data)

class SignedWriter(object):
    def __init__(self, key, f):
        self.f = f
        self.key = key
        self.buffer = bytearray()

    def add(self, data):
        self.buffer += data
        while len(self.buffer) >= 0x400:
            signature = pyhy.hydro_sign_create(bytes(self.buffer[:0x400]), CONTEXT, self.key)
            self.f.write(self.buffer[:0x400])
            self.f.write(signature)
            self.buffer = self.buffer[0x400:]
            print(len(self.buffer))

def protect_sample(in_path, out_path, song_id, owner_id, aes_key, signing_key):
    with open(in_path, "rb") as f:
        riff_magic  = f.read(0x04)
        riff_header = f.read(0x20)
        assert(riff_magic == b"RIFF")

        # Find the cut-off point for the end of the sample.
        channels = u16d(riff_header[18:20])
        sample_freq = u32d(riff_header[20:24])
        bits_per_sample = u16d(riff_header[-2:])
        bytes_per_second = channels * sample_freq * (bits_per_sample // 8)
        bytes_to_write = 30 * bytes_per_second

        data_magic  = f.read(0x04)
        data_length = f.read(0x04)
        assert(data_magic == b"data")
        data = f.read(u32d(data_length))

    with open(out_path + ".p", "wb+") as f:
        iv = get_random_bytes(8)
        writer = SignedWriter(signing_key, f)

        # Write the .drm.p header
        writer.add(u8e(song_id))                   # u8 song_id;
        writer.add(u8e(owner_id))                  # u8 owner_id;
        writer.add(iv)                             # u8 nonce[16]; // The CTR IV.
        writer.add(u32e(0))                        # u8 nonce[16]; // The CTR step.
        writer.add(b"\x00" * (0x400 - 16 + 1 + 1)) # // Padding to 1024 bytes.

        # Write the wav header.
        writer.add(riff_magic)
        writer.add(riff_header)
        writer.add(data_magic)
        writer.add(u32e(bytes_to_write))

        # Write the actual data.
        encrypted = encrypt_data(data[:bytes_to_write], aes_key, iv)
        writer.add(encrypted)

def create_metadata(regions, user, user_secret_location, region_info):
    """Returns a byte string formatted as follows:
    METADATA_LENGTH(1B)/ownerID(1B)/REGION_LEN(1B)/USER_LEN(1B)/REGIONID1(1B)/REGIONID2 (1B)/.../opt. parity
    Args:
        regions (list): list of regions to provision song for
        user (string): user name for owner of the song
        user_secret_location (string): path to user secrets file
        region_info (dict): mapping of regions provided by region_information.json
    Returns:
        metadata (bytes): bytes of encoded metadata
    Example:
        >>create_metadata(['USA', 'Canada'], 'user1', 'user_secrets.json', {'USA': 1, 'Canada':2})
        'x06/x00/x01/x00/x01/x02'
    """
    user_secrets = json.load(open(os.path.abspath(user_secret_location)))

    # note: metadata must be an even length since each sample is 2B long
    # and ARM processors require memory accesses to be aligned to the type size
    metadata = struct.pack(
        '=3B{regions_length}s{regions_len_2}s'.format(regions_length=len(regions), regions_len_2=len(regions) % 2),
        int(user_secrets[user]['id']), len(regions), 0,
        bytes([region_info[str(r)] for r in regions]),
        b'\x00' if len(regions) % 2 else b'')

    return bytes([len(metadata) + 1]) + metadata


def main():
    parser = ArgumentParser(description='main interface to protect songs')
    parser.add_argument('--region-list', nargs='+', help='List of regions song can be played in', required=True)
    parser.add_argument('--region-secrets-path', help='File location for the region secrets file',
                        required=True)
    parser.add_argument('--outfile', help='path to save the protected song', required=True)
    parser.add_argument('--infile', help='path to unprotected song', required=True)
    parser.add_argument('--owner', help='owner of song', required=True)
    parser.add_argument('--user-secrets-path', help='File location for the user secrets file', required=True)
    parser.add_argument('--system-secrets-path', help='File location for the system secrets file', required=True)
    args = parser.parse_args()

    regions = json.load(open(os.path.abspath(args.region_secrets_path)))
    keys = json.load(open(os.path.abspath(args.system_secrets_path)))
    try:
        metadata = create_metadata(args.region_list, args.owner, args.user_secrets_path, regions)
    except ValueError:
        raise ValueError('Ensure all user IDs are integers and all regions are in the provided region_information.json')

    system_symmetric_key = binascii.unhexlify(keys["system_symmetric_key"])
    system_integrity_ecc_key_priv =  binascii.unhexlify(keys["system_integrity_ecc_key_priv"])
    protect_sample(
        args.infile,
        args.outfile,
        0,
        0,
        system_symmetric_key,
        system_integrity_ecc_key_priv
    )

if __name__ == '__main__':
    main()
